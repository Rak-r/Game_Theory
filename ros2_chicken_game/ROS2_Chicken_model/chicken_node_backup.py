#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Pose, PoseArray, Twist, PoseWithCovarianceStamped, Point
import tf2_ros
from yolov8_msgs.msg import Detection
from yolov8_msgs.msg import DetectionArray
import message_filters
from nav_msgs.msg import Path
import numpy as np
from nav2_simple_commander.line_iterator import LineIterator
from sequentialChicken import ChickenGame
import random
from time import time
from visualization_msgs.msg import Marker
from rclpy.duration import Duration


class ChickenSpeedModulatorNode(Node):

    def __init__(self):
        super().__init__('chicken_speed_modulator_node')

        self.get_logger().info('Chicken Modulator node is initialised')


        #Parameters

        self.declare_parameters(
            namespace='',
            parameters=[
                ('use_waypoint_segment', True)
            ])

        self.use_waypoint_segment = self.get_parameter('use_waypoint_segment').value

        # subscribers
        
        self.robot_pose_sub = self.create_subscription(PoseWithCovarianceStamped, '/localization_pose', self.robot_pose_cb, 10)                    # the robot pose in global frame (map)
        self.robot_vel_callback = self.create_subscription(Odometry, '/odom', self.robot_vel_cb, 10)
        self.global_plan_sub = self.create_subscription(Path, '/plan', self.robot_global_plan_cb, 10)                                 # path message generated  y nav2 global planner
        self.cmd_vel_sub = self.create_subscription(Twist, '/cmd_vel', self.cmd_vel_cb, 10)                                           # orginal twist generated by nav2 
        

        # add message filter synchronizer for pedestrian related messages to avoid time inaccuracies
        self.pedestrian_pose_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_3d')                            # pedestrian pose in global frame (map)
        self.pedestrian_vel_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_speed')                          # pedestrian speed topic
        self.synchronizer = message_filters.ApproximateTimeSynchronizer((self.pedestrian_pose_sub, self.pedestrian_vel_sub), 10, 0.5)
        self.synchronizer.registerCallback(self.Pedestrian_state_cb)
        
        # publisher
        self.modulated_twist_pub = self.create_publisher(Twist, '/cmd_vel_chicken_modulated', 10)
        self.marker_pub = self.create_publisher(Marker, '/collsion_point', 10)
        # self.timer_callback = self.create_timer(1.0, self.cmd_vel_cb)
       
        self.monitor_callbacks = self.create_timer(1.0, self.is_callback_triggered)                                                    # timer callback to check messages recived or not

        # ROBOT SPECIFIC VARIABLES

        self.robot_pose_x = 0.0                                                                                                        # initialize robot pose
        self.robot_pose_y = 0.0
        self.robot_max_vel = 0.2                      # NOTE set maximum robot speed (assuming FAST)
        self.robot_vel = 0.0                          # magnitude of current velocity
        self.robot_poses = []                                                                                                          # list to store the robot poses over a trajectory
        self.x_closest = 0.0
        self.y_closest = 0.0
        self.waypoints = []                                                                                                            # list to store extracted waypoint information from NAV2 Path message
        self.robot_time_to_collision = np.inf
        self.robot_dist = 0.0
        # PEDESTRIAN SPECIFIC VARIABLES
        self.px_ms = np.nan                                                                                               # taken from real readings just for code testing
        self.py_ms = np.nan
        self.ped_max_vel = 0.2                                                                                                           # Avg. walking speed of human ( Btw 0.9 and 1.2 m/s)
        self.ped_pose_x = np.nan                                                                                                       # nan means there is no pedestrian in the scene
        self.ped_pose_y = np.nan 
        self.min_dist = 0.8
        self.ped_dist = 0.0
        self.if_pedestrian = False                                                                                                     # bool to catch if there is pedestrian or not
        self.is_plan = False
        self.ped_time_to_collision = np.inf
        # COLLISION CHECKING VARIABLES
       
        # create instance of chicken game class
        self.game_of_chicken = ChickenGame()
        self.b_yield = False
        self.old_time = time()

        self.V,self.S = self.game_of_chicken.solveGame(U_crash_Y=-100, U_crash_X=-100, U_time=1., NY=30, NX=30)
       
        
    '''
    callback to subscribe to NAV2 Path message from global planner server
    '''
    def robot_global_plan_cb(self, msg):
        self.is_plan = True
        waypoints = [(pose.pose.position.x, pose.pose.position.y) for pose in msg.poses]                                                 # extract the waypoints of the global plan
        self.waypoints = np.array(waypoints)
        # print(self.waypoints)
            
    '''
    callback to subscribe to RTABMAP SLAM'S Pose message for robot pose info in MAP frame
    ''' 
    def robot_pose_cb(self, msg):
        
        pose = PoseWithCovarianceStamped()
        
        self.robot_pose_x = msg.pose.pose.position.x
        self.robot_pose_y = msg.pose.pose.position.y
        self.robot_poses.append((self.robot_pose_x, self.robot_pose_y))
        
    '''
    callback to subscribe to Yolo output to get pedestrian position in world frame
    '''
    def Pedestrian_state_cb(self, pose_msg: DetectionArray, speed_msg: DetectionArray):
        
        self.if_pedestrian = True
        # # TODO, this needs to go somewhere else because this callback will get triggered only when there are incoming messages
        # if not speed_msg:
        #     self.px_ms = np.nan
        #     self.py_ms = np.nan
        #     self.ped_pose_x = np.nan
        #     self.ped_pose_y = np.nan
        
        for detection in speed_msg.detections:

            # self.px_ms = detection.velocity.linear.x
            # self.py_ms = detection.velocity.linear.y
            self.px_ms = 0.0
            self.py_ms = -1.0
           
        for detection in pose_msg.detections:
            
            # store the x and y positions of the detected and tracked pedestrian
            self.ped_pose_x = detection.bbox3d.center.position.x
            self.ped_pose_y = detection.bbox3d.center.position.y
            
    '''
    callback to subscribe to NAV2 generated twist message
    '''  
    def robot_vel_cb(self, msg):
        self.robot_vel = np.sqrt(msg.twist.twist.linear.x**2 + msg.twist.twist.linear.y**2)
    
    '''
    Function to keep track if the callback is triggered or not and reset the attributes.
    '''
    def is_callback_triggered(self):

        if self.is_plan:
            self.waypoints = []
        if not self.if_pedestrian:
            self.px_ms = np.nan
            self.py_ms = np.nan
            self.ped_pose_x = np.nan
            self.ped_pose_y = np.nan
        
        self.if_pedestrian = False
        self.is_plan = False

    def publish_collision_marker(self, x, y, r,g,b, scale):
        marker = Marker()
        marker.header.frame_id = "map"
        # marker.header.stamp = self.get_clock().now().nanoseconds / 1e9
        marker.ns = "collision_points"
        marker.id = 0
        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        marker.pose.position.x = x
        marker.pose.position.y = y
        marker.pose.position.z = 0.0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = scale
        marker.scale.y = scale
        marker.scale.z = scale
        marker.color.a = 1.0
        marker.color.r = r
        marker.color.g = g
        marker.color.b = b
        marker.lifetime = Duration(seconds=0.5).to_msg()

        self.marker_pub.publish(marker)
    '''
    1.) Function to calculate the distance between a point and the line

    2.) returns: condition to check, distance between the single NAV2 pose/waypiont or pedestrain slope-intercept
    
    '''
    #https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Another_formula
    def doesWaypointIntersectPedPath(self,wx,wy, m, c):  
    
        a = m
        b = -1
       
        numerator = abs(a * wx + b * wy + c)
        denominator = np.sqrt(a**2 + b**2) 
        distance = numerator / denominator
        
        return (distance < self.min_dist)

    '''
    Need to find the closest point on ped line from robot current pose
    '''
    def closest_point_on_line(self, wx, wy, m, c):
        # Line equation: y = mx + c
        # Perpendicular line from (rx, ry): y = (-1/m)x + b
        # Find b for the perpendicular line: ry = (-1/m)rx + b => b = ry + (rx / m)
        
        b_perp = wy + (wx / m)
        
        # Intersection point of the two lines: mx + c = (-1/m)x + b_perp
        # Solve for x: mx + (1/m)x = b_perp - c => x(m + 1/m) = b_perp - c => x = (b_perp - c) / (m + 1/m)
        
        x_closest = (b_perp - c) / (m + 1/m)
        y_closest = m * x_closest + c
        
        return x_closest, y_closest
   

    '''
    REAL WORK HERE  !!!  Function to check the test if a single pose and speed will collide close to a temporal trajectory
    '''
    def doesWaypointIntersectTrajectory(self, wx,wy,m,c, speedped, speedrobot, current_robot_x, current_robot_y):  
    
         # Handle zero division for speeds
        if speedrobot < 0.001:                                                                                       # no need for abs becuase taking magnitudes
            speedrobot = 0.01                                                                                        # Set minimum speed for robot
        if speedped < 0.001:
            speedped = 0.01                                                                                          # Set minimum speed for pedestrian

        if not self.doesWaypointIntersectPedPath(wx, wy, m, c):                                                          # if path dont intersect , no way trajectory will intersect
            return (np.inf, np.inf, np.inf, np.inf)                                                                                        # inf means there is no intersection
       
        x_closest, y_closest = self.closest_point_on_line(wx, wy, m, c)
        # self.publish_collision_marker(x_closest, y_closest, 1.,0.,0., 0.2)
        
        distance_robot_to_closest = np.sqrt((current_robot_x - x_closest)**2 + (current_robot_y - y_closest)**2)                               # TODO use the curve path instead of assuming straight
        distance_ped_to_closest = np.sqrt((self.ped_pose_x - x_closest)**2 + (self.ped_pose_y - y_closest)**2)
        
        time_robot_to_collsion = distance_robot_to_closest/speedrobot
        time_ped_to_collision = distance_ped_to_closest/speedped

        # self.get_logger().info(f'rd: {distance_robot_to_closest}, r_t: {time_robot_to_collsion}, pd: {distance_ped_to_closest}, p_t: {time_ped_to_collision}')
        
        if abs(time_robot_to_collsion-time_ped_to_collision) <= 0.5:   #check for temporal collision
            self.publish_collision_marker(x_closest, y_closest, 0.,0.,1.,0.3 )
            return (time_robot_to_collsion, time_ped_to_collision, distance_robot_to_closest, distance_ped_to_closest)
        else:
            return (np.inf, np.inf, np.inf, np.inf) 


    def cmd_vel_cb(self, msg):
        
        # print(f'before game: {msg.linear.x}' )
        curr_time = time()
        delta_time = curr_time - self.old_time
        
        if abs(self.px_ms) <= 0.0001:                                                                                      # handle zero-division
            self.px_ms = 0.001
        if abs(self.py_ms) <=0.0001:
            self.py_ms = 0.001
        if not self.if_pedestrian:                                                                                      # if no pedestrian , do nothing                
            self.modulated_twist_pub.publish(msg)
            
            return         
        
        #ped_speed = np.sqrt((self.px_ms)**2 + (self.py_ms)**2)
        m = self.py_ms/self.px_ms     #gradient pf ped trajectory in map frame
        c = self.ped_pose_y - m*self.ped_pose_x                                                 # c = y - mx
        # print(m,c)
        # t_intersect, robot_dist_to_collision, ped_dist_to_collision = self.doesPlanIntersectTrajectory(self.waypoints, self.slope, self.intercept, self.robot_pose_x, self.robot_pose_y)
       
        b_temporalCollision = False   #have we found a temporal collision?                                          
        for waypoint in self.waypoints:
            wx, wy = waypoint                  
            (time_robot_to_collsion, time_ped_to_collision, distance_robot_to_closest, distance_ped_to_closest) = self.doesWaypointIntersectTrajectory(wx,wy, m,c, self.ped_max_vel, self.robot_max_vel, self.robot_pose_x, self.robot_pose_y)
            
            if not np.isinf(time_robot_to_collsion):
                b_temporalCollision = True
                break
        b_update=False
        if b_temporalCollision:
            X = int(round(distance_robot_to_closest*5))                                                             # Discretise the points to nearest ints                                                                                                             # NOTE Quantise points to 1 meter boxes
            Y = int(round(distance_ped_to_closest*5))

            # if we played chicken once, then do the original but if the time played chicken exceeds some thresh again play
           
            # if delta_time > 0.5:                                                                                      # NOTE check time is in seconds not millis
            b_update=True
            #lets play chicken
            prob_robot_yield = self.S[Y, X, 0]  
                                                                                        # Action the robot should take either yeild (SLOW) or not yield, carry on (FAST)                        
            prob_ped_yield = self.S[Y, X, 1]   
            r1 = random.random()                                                                                            # Create a random probabilty range (prob. is max 1)
            if r1 < prob_robot_yield:                                
                self.b_yield =  False   #slow                                                                                        # Slow down the robot by halving the speed in linear.x (fwd/ bkd velocity)  
            else:
                self.b_yield = True     #go fast

            #debug info
            np.set_printoptions(threshold=np.inf, precision=3, linewidth=200, suppress=True)
            self.get_logger().info(f'X: {X}, Y: {Y}, y:{self.b_yield}, PRY: {prob_robot_yield}, PPY: {prob_ped_yield}, upte: {b_update}')


            self.old_time = curr_time
        if self.b_yield:
            msg.linear.x/=2



        # print('\n')
        # msg.linear.x =0.0
        self.modulated_twist_pub.publish(msg)



    def play_chicken(self, S, X, Y):  
        '''
        1.) Here, two players ae robot and pedestrian.
        2.) The row player is robot, and the colum player is pedestrian.
        3.) S is the strategy matrix consisting the most optimal actions (FAST/SLOW) to be taken by the robot based on the pedetrian strategy.
        4.) The functions takes the solved strategy matrix, x point =  distance from collsion point and Ped pose, y point = dist. from collsion point and robot pose
        '''                     
        
                                            
    


def main():
    rclpy.init()
    node = ChickenSpeedModulatorNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()




    