#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Pose, PoseArray, Twist, PoseWithCovarianceStamped, Point
import tf2_ros
from yolov8_msgs.msg import Detection
from yolov8_msgs.msg import DetectionArray
import message_filters
from nav_msgs.msg import Path
import numpy as np
from nav2_simple_commander.line_iterator import LineIterator
from sequentialChicken import ChickenGame
import random
from time import time
from visualization_msgs.msg import Marker



class ChickenSpeedModulatorNode(Node):

    def __init__(self):
        super().__init__('chicken_speed_modulator_node')

        self.get_logger().info('Chicken Modulator node is initialised')


        #Parameters

        self.declare_parameters(
            namespace='',
            parameters=[
                ('use_waypoint_segment', True)
            ])

        self.use_waypoint_segment = self.get_parameter('use_waypoint_segment').value

        # subscribers
        
        self.robot_pose_sub = self.create_subscription(PoseWithCovarianceStamped, '/localization_pose', self.robot_pose_cb, 10)                    # the robot pose in global frame (map)
        self.robot_vel_callback = self.create_subscription(Odometry, '/odom', self.robot_vel_cb, 10)
        self.global_plan_sub = self.create_subscription(Path, '/plan', self.robot_global_plan_cb, 10)                                 # path message generated  y nav2 global planner
        self.cmd_vel_sub = self.create_subscription(Twist, '/cmd_vel', self.cmd_vel_cb, 10)                                           # orginal twist generated by nav2 
        

        # add message filter synchronizer for pedestrian related messages to avoid time inaccuracies
        self.pedestrian_pose_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_3d')                            # pedestrian pose in global frame (map)
        self.pedestrian_vel_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_speed')                          # pedestrian speed topic
        self.synchronizer = message_filters.ApproximateTimeSynchronizer((self.pedestrian_pose_sub, self.pedestrian_vel_sub), 10, 0.5)
        self.synchronizer.registerCallback(self.Pedestrian_state_cb)
        
        # publisher
        self.modulated_twist_pub = self.create_publisher(Twist, '/cmd_vel_chicken_modulated', 10)
        self.marker_pub = self.create_publisher(Marker, '/collsion_point', 10)
        # self.timer_callback = self.create_timer(1.0, self.cmd_vel_cb)
       
        self.monitor_callbacks = self.create_timer(1.0, self.is_callback_triggered)                                                    # timer callback to check messages recived or not

        # ROBOT SPECIFIC VARIABLES

        self.robot_pose_x = 0.0                                                                                                        # initialize robot pose
        self.robot_pose_y = 0.0
        self.robot_max_vel = 0.2                      # NOTE set maximum robot speed (assuming FAST)
        self.robot_vel = 0.0                          # magnitude of current velocity
        self.robot_poses = []                                                                                                          # list to store the robot poses over a trajectory
        self.x_closest = 0.0
        self.y_closest = 0.0
        self.waypoints = []                                                                                                            # list to store extracted waypoint information from NAV2 Path message
        self.robot_time_to_collision = np.inf
        self.robot_dist = 0.0
        # PEDESTRIAN SPECIFIC VARIABLES
        self.px_ms = np.nan                                                                                               # taken from real readings just for code testing
        self.py_ms = np.nan
        self.ped_max_vel = 0.7                                                                                                           # Avg. walking speed of human ( Btw 0.9 and 1.2 m/s)
        self.ped_pose_x = np.nan                                                                                                       # nan means there is no pedestrian in the scene
        self.ped_pose_y = np.nan 
        self.min_dist = 0.8
        self.ped_dist = 0.0
        self.if_pedestrian = False                                                                                                     # bool to catch if there is pedestrian or not
        self.is_plan = False
        self.ped_time_to_collision = np.inf
        # COLLISION CHECKING VARIABLES
        self.slope = 0.0
        self.intercept = 0.0
        self.line_segment_length = 0.0

        # create instance of chicken game class
        self.game_of_chicken = ChickenGame()
        self.b_fast = True
        self.old_time = time()

        self.V,self.S = self.game_of_chicken.solveGame(U_crash_Y=-100, U_crash_X=-100, U_time=1., NY=20, NX=20)
        self.game_played = False 
        self.prob_robot_yield = 0.0
        self.X = 0.0
        self.Y = 0.0
    '''
    callback to subscribe to NAV2 Path message from global planner server
    '''
    def robot_global_plan_cb(self, msg):
       
        waypoints = [(pose.pose.position.x, pose.pose.position.y) for pose in msg.poses]                                                 # extract the waypoints of the global plan
        self.waypoints = np.array(waypoints)
        # print(self.waypoints)
            
    '''
    callback to subscribe to RTABMAP SLAM'S Pose message for robot pose info in MAP frame
    ''' 
    def robot_pose_cb(self, msg):
        
        pose = PoseWithCovarianceStamped()
        
        self.robot_pose_x = msg.pose.pose.position.x
        self.robot_pose_y = msg.pose.pose.position.y
        self.robot_poses.append((self.robot_pose_x, self.robot_pose_y))
        
    '''
    callback to subscribe to Yolo output to get pedestrian position in world frame
    '''
    def Pedestrian_state_cb(self, pose_msg: DetectionArray, speed_msg: DetectionArray):
        
        self.if_pedestrian = True
        # # TODO, this needs to go somewhere else because this callback will get triggered only when there are incoming messages
        # if not speed_msg:
        #     self.px_ms = np.nan
        #     self.py_ms = np.nan
        #     self.ped_pose_x = np.nan
        #     self.ped_pose_y = np.nan
        
        for detection in speed_msg.detections:

            # self.px_ms = detection.velocity.linear.x
            # self.py_ms = detection.velocity.linear.y
            self.px_ms = 0.0
            self.py_ms = -1.0
           
        for detection in pose_msg.detections:
            
            # store the x and y positions of the detected and tracked pedestrian
            self.ped_pose_x = detection.bbox3d.center.position.x
            self.ped_pose_y = detection.bbox3d.center.position.y
            
    '''
    callback to subscribe to NAV2 generated twist message
    '''  
    def robot_vel_cb(self, msg):
        self.robot_vel = np.sqrt(msg.twist.twist.linear.x**2 + msg.twist.twist.linear.y**2)
    
    '''
    Function to keep track if the callback is triggered or not and reset the attributes.
    '''
    def is_callback_triggered(self):

        if self.is_plan:
            self.waypoints = np.nan
        if not self.if_pedestrian:
            self.px_ms = np.nan
            self.py_ms = np.nan
            self.ped_pose_x = np.nan
            self.ped_pose_y = np.nan
        
        self.if_pedestrian = False
        self.is_plan = False

    def publish_collision_marker(self, x, y, r,g,b, scale):
        marker = Marker()
        marker.header.frame_id = "map"
        # marker.header.stamp = self.get_clock().now().nanoseconds / 1e9
        marker.ns = "collision_points"
        marker.id = 0
        marker.type = Marker.SPHERE
        marker.action = Marker.ADD
        marker.pose.position.x = x
        marker.pose.position.y = y
        marker.pose.position.z = 0.0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = scale
        marker.scale.y = scale
        marker.scale.z = scale
        marker.color.a = 1.0
        marker.color.r = r
        marker.color.g = g
        marker.color.b = b

        self.marker_pub.publish(marker)
    '''
    1.) Function to calculate the distance between a point and the line

    2.) returns: condition to check, distance between the single NAV2 pose/waypiont or pedestrain slope-intercept
    
    '''
    #https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Another_formula
    def doesWaypointIntersectPedPath(self,wx,wy, m, c):  
    
        a = m
        b = -1
       
        numerator = abs(a * wx + b * wy + c)
        denominator = np.sqrt(a**2 + b**2) 
        distance = numerator / denominator
        
        return (distance < self.min_dist)

    '''
    Need to find the closest point on ped line from robot current pose
    '''
    def closest_point_on_line(self, wx, wy, m, c):
        # Line equation: y = mx + c
        # Perpendicular line from (rx, ry): y = (-1/m)x + b
        # Find b for the perpendicular line: ry = (-1/m)rx + b => b = ry + (rx / m)
        
        b_perp = wy + (wx / m)
        
        # Intersection point of the two lines: mx + c = (-1/m)x + b_perp
        # Solve for x: mx + (1/m)x = b_perp - c => x(m + 1/m) = b_perp - c => x = (b_perp - c) / (m + 1/m)
        
        x_closest = (b_perp - c) / (m + 1/m)
        y_closest = m * x_closest + c
        
        return x_closest, y_closest
   

   
    '''
    Function to check the test if a single pose and speed will collide close to a temporal trajectory
    '''
    def doesWaypointIntersectTrajectory(self, wx,wy,m,c, speedped, speedrobot, current_robot_x, current_robot_y):  
        
         # Handle zero division for speeds
        if speedrobot < 0.001:                                                                                       # no need for abs becuase taking magnitudes
            speedrobot = 0.01                                                                                        # Set minimum speed for robot
        if speedped < 0.001:
            speedped = 0.01                                                                                          # Set minimum speed for pedestrian

        if not self.doesWaypointIntersectPedPath(wx, wy, m, c):                                                          # if path dont intersect , no way trajectory will intersect
            return np.inf                                                                                         # inf means there is no intersection
       
        x_closest, y_closest = self.closest_point_on_line(wx, wy, m, c)
        self.publish_collision_marker(x_closest, y_closest, 1.,0.,0., 0.2)
        
        
        distance_robot_to_closest = np.sqrt((current_robot_x - x_closest)**2 + (current_robot_y - y_closest)**2)                               # TODO use the curve path instead of assuming straight

        distance_ped_to_closest = np.sqrt((self.ped_pose_x - x_closest)**2 + (self.ped_pose_y - y_closest)**2)
        self.get_logger().info(f'robot_dist: {distance_robot_to_closest}, ped_dist: {distance_ped_to_closest}')
        
        time_robot_to_collsion = distance_robot_to_closest/speedrobot
        time_ped_to_collision = distance_ped_to_closest/speedped

        if abs(time_robot_to_collsion-time_ped_to_collision) <= 0.5:   #check for temporal collision
            self.publish_collision_marker(x_closest, y_closest, 0.,0.,1.,0.5 )
                                                                               # both times are nearly equal
            return time_robot_to_collsion
        else:
            
            return np.inf 
    '''
    Function to check that does a complete plan (list of poses) temporally intersect a trajectory?
    '''

    def doesPlanIntersectTrajectory(self, plan,  m,c, current_robot_x, current_robot_y):                        # Assuming both robot and Pedestrian travel at their fastest speed
                                                           
        for waypoint in plan:
            wx, wy = waypoint
                                            
            collsion_time = self.doesWaypointIntersectTrajectory(wx,wy, m,c, self.ped_max_vel, self.robot_max_vel, current_robot_x, current_robot_y)
           
            if not np.isinf(collsion_time):
                return collsion_time
               
        return np.inf
    

                                            
    
    def cmd_vel_cb(self, msg):
        
        # print(f'before game: {msg.linear.x}' )
        curr_time = time()
        delta_time = curr_time - self.old_time
        
        if self.px_ms <= 0.0001:                                                                                      # handle zero-division
            self.px_ms = 0.001
        if self.py_ms <=0.0001:
            self.py_ms = 0.001
        if np.isnan(self.px_ms):                                                                                      # if no pedestrian , do nothing
            return msg                
        
        self.slope = self.py_ms/self.px_ms
        self.intercept = self.ped_pose_y - self.slope*self.ped_pose_x                                                 # c = y - mx
        
        # t_intersect, robot_dist_to_collision, ped_dist_to_collision = self.doesPlanIntersectTrajectory(self.waypoints, self.slope, self.intercept, self.robot_pose_x, self.robot_pose_y)
        t_intersect = self.doesPlanIntersectTrajectory(self.waypoints, self.slope, self.intercept, self.robot_pose_x, self.robot_pose_y)

        
        if np.isinf(t_intersect):    
                                                                                       # NO collision happening at this point
            self.game_played = False                                                            # publish the same cmd_vel      
        else:                                                                                                         # Let's play the Chicken Game
            self.game_played = True
            robot_dist_to_collision = self.robot_max_vel*t_intersect

            x_intersect = (self.intercept - self.ped_pose_y)/self.slope
            y_intersect = self.slope*x_intersect + self.intercept

            ped_dist_to_collision = np.sqrt((self.ped_pose_x - x_intersect)**2 + (self.ped_pose_y - y_intersect)**2)

            self.ped_dist = ped_dist_to_collision
            self.robot_dist = robot_dist_to_collision
            self.X = int(round(robot_dist_to_collision))                                                             # Discretise the points to nearest ints
                                                                                                                # NOTE Quantise points to 1 meter boxes
            self.Y = int(round(ped_dist_to_collision))

            # self.get_logger().info(f'Robot position: {X}, Ped positon: {Y}')


            # if we played chicken once, then do the original but if the time played chicken exceeds some thresh again play

            if delta_time > 0.5:                                                                                      # NOTE check time is in seconds not millis
                # self.b_fast =  self.play_chicken(self.S, self.X, self.Y)
                pass
                self.old_time = curr_time
            if self.b_fast:
                msg.linear.x/=2

        
        np.set_printoptions(threshold=np.inf, precision=3, linewidth=200, suppress=True)
        # self.get_logger().info(f'strategy matrix: {self.S}')
        self.get_logger().info(f'Robot_dist: {round(self.robot_dist,3)}, R_time {round(self.robot_time_to_collision,3)}, R_curr_x: {round(self.robot_pose_x,3)}, R_curr_y{round(self.robot_pose_y,3)} P_dist: {round(self.ped_dist,3)}, P_time {round(self.ped_time_to_collision,3)}, X_close: {round(self.x_closest,3)}, Y_close: {round(self.y_closest,3)}, Game_Played : {self.game_played}, PRY: {round(self.prob_robot_yield,3)}, Game_twist: {msg.linear.x}, R_player: {self.X}, P_player: {self.Y}')
        print('\n')

        # msg.linear.x =0.0
        self.modulated_twist_pub.publish(msg)





    def play_chicken(self, S, X, Y):  

        '''
        1.) Here, two players ae robot and pedestrian.

        2.) The row player is robot, and the colum player is pedestrian.

        3.) S is the strategy matrix consisting the most optimal actions (FAST/SLOW) to be taken by the robot based on the pedetrian strategy.

        4.) The functions takes the solved strategy matrix, x point =  distance from collsion point and Ped pose, y point = dist. from collsion point and robot pose
        '''                     
       
        Fast = True
        Slow = False
        
        self.prob_robot_yield = S[Y, X, 0]  
        # self.get_logger().info(f'Robot yied prob : {self.prob_robot_yield}')                                                                                 # Action the robot should take either yeild (SLOW) or not yield, carry on (FAST)                        
        prob_ped_yield = S[Y, X, 1]   
        r1 = random.random()                                                                                            # Create a random probabilty range (prob. is max 1)
        
        if r1 < self.prob_robot_yield:  
            print('slowing robot')                                                                                     # check the robot should yeild (SLOW) if yeild probility is higher  
            return  Slow                                                                                                # Slow down the robot by halving the speed in linear.x (fwd/ bkd velocity)  
        else:
            return Fast

def main():
    rclpy.init()
    node = ChickenSpeedModulatorNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()




    





