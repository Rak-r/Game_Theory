#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Pose, PoseArray, Twist, PoseWithCovarianceStamped
import tf2_ros
from yolov8_msgs.msg import Detection
from yolov8_msgs.msg import DetectionArray
import message_filters
from nav_msgs.msg import Path
import numpy as np
from nav2_simple_commander.line_iterator import LineIterator
from sequentialChicken import ChickenGame
import random
from time import time



class ChickenSpeedModulatorNode(Node):

    def __init__(self):
        super().__init__('chicken_speed_modulator_node')
        
        # subscribers
        
        self.robot_pose_sub = self.create_subscription(PoseWithCovarianceStamped, '/pose', self.robot_pose_cb, 10)                    # the robot pose in global frame (map)
        self.robot_vel_callback = self.create_subscription(Odometry, '/odom', self.robot_vel, 10)
        self.global_plan_sub = self.create_subscription(Path, '/plan', self.robot_global_plan_cb, 10)                                 # path message generated  y nav2 global planner
        self.cmd_vel_sub = self.create_subscription(Twist, '/cmd_vel', self.cmd_vel_cb, 10)                                           # orginal twist generated by nav2 
        

        # add message filter synchronizer for pedestrian related messages to avoid time inaccuracies
        self.pedestrian_pose_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_3d')                            # pedestrian pose in global frame (map)
        self.pedestrian_vel_sub = message_filters.Subscriber(self, DetectionArray, '/yolo/detections_speed')                          # pedestrian speed topic
        self.synchronizer = message_filters.ApproximateTimeSynchronizer((self.pedestrian_pose_sub, self.pedestrian_vel_sub), 10, 0.5)
        self.synchronizer.registerCallback(self.Pedestrian_state_cb)
        
        # publisher
        self.modulated_twist_pub = self.create_publisher(Twist, '/cmd_vel_chicken_mdoluted', 10)

        self.get_logger().info('Chicken Modulator node is initialised')

        # ROBOT SPECIFIC VARIABLES

        self.robot_pose_x = 0.0                                                                                                        # initialize robot pose
        self.robot_pose_y = 0.0
        self.robot_vel = 0.0                                                                                                           # initialize robot velocity
        self.robot_poses = []                                                                                                          # list to store the robot poses over a trajectory
        
        self.waypoints = []                                                                                                            # list to store extracted waypoint information from NAV2 Path message
        
        # PEDESTRIAN SPECIFIC VARIABLES
        self.px_ms = 0.227127150                                                                                                       # taken from real readings just for code testing
        self.py_ms = 0.685486019
        self.ped_pose_x = 0.0
        self.ped_pose_y = 0.0
        self.min_dist = 0.01
        self.bbox_size = []
        self.bbox_center = []
        # COLLISION CHECKING VARIABLES
        self.slope = 0.0
        self.intercept = 0.0
        self.line_segment_length = []

        self.old_time = time()
        # create instance of chicken game class
       # create instance of chicken game class
        self.game_of_chicken = ChickenGame()
        self.b_fast = True
        self.old_time = time()

        self.V,self.S = self.game_of_chicken.solveGame(U_crash_Y=-100, U_crash_X=-100, U_time=1., NY=20, NX=20)
        self.game_played = False 
        self.prob_robot_yield = 0.0
        self.X = 0.0
        self.Y = 0.0

    '''
    callback to subscribe to NAV2 Path message from global planner server
    '''
    def robot_global_plan_cb(self, msg):
       
        waypoints = [(pose.pose.position.x, pose.pose.position.y) for pose in msg.poses]                                                 # extract the waypoints of the global plan
        self.waypoints = waypoints
        # print(self.waypoints)

        
    '''
    callback to subscribe to RTABMAP SLAM'S Pose message for robot pose info in MAP frame
    ''' 
    def robot_pose_cb(self, msg):
        
        pose = PoseWithCovarianceStamped()
        
        self.robot_pose_x = msg.pose.pose.position.x
        self.robot_pose_y = msg.pose.pose.position.y
        self.robot_poses.append((self.robot_pose_x, self.robot_pose_y))

    '''
    callback to subscribe to Yolo output to get pedestrian position in world frame
    '''
    def Pedestrian_state_cb(self, pose_msg: DetectionArray, speed_msg: DetectionArray):
        
        # if not speed_msg:
        #     return np.inf
        # else:
            
        #     for detection in speed_msg.detections:

        #         self.px_ms = detection.velocity.linear.x
        #         self.py_ms = detection.velocity.linear.y

        for detection in pose_msg.detections:
            
            # store the x and y positions of the detected and tracked pedestrian
            ped_pose_x = detection.bbox3d.center.position.x
            ped_pose_y = detection.bbox3d.center.position.y
            bbox_size_x = detection.bbox3d.size.x
            bbox_size_y = detection.bbox3d.size.y
            self.bbox_center.append((ped_pose_x, ped_pose_y))
            self.bbox_size.append((bbox_size_x, bbox_size_y))

    '''
    callback to subscribe to NAV2 generated twist message
    '''  
    def robot_vel(self, msg):
        
        vx_ms = msg.twist.twist.linear.x                                                                 # velocity in x in m/s
        vy_ms = msg.twist.twist.linear.y                                                                  # velocity in y in m/s
        self.robot_vel = np.sqrt(vx_ms**2 + vy_ms**2)

    '''
    1.) Function to calculate the distance between a point and the line

    2.) returns: condition to check, distance between the single NAV2 pose/waypiont or pedestrain slope-intercept
    
    '''
    #https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Another_formula
    def doesPoseIntersectPedPath(self,rx,ry, m, c):  
        
        a = m
        b = -1
        # Calculate the numerator of the distance formula
        numerator = abs(a * rx + b * ry + c)
        # Calculate the denominator of the distance formula
        denominator = np.sqrt(a**2 + b**2) 
        # Calculate the distance
        distance = numerator / denominator
        
        return (distance < self.min_dist), distance


    def direction(self, a, b):

        dir = b-a
        return dir
    
    

    def time_to_reach_end_point(self, velocity: float, line_segment_length: float):

        time = velocity*line_segment_length
        return time

    def calculate_bbox_corners(self, bbox_center, bbox_size):
        cx, cy = bbox_center
        w, h = bbox_size
        half_w, half_h = w / 2, h / 2

        return [
            (cx - half_w, cy - half_h),
            (cx + half_w, cy - half_h),
            (cx + half_w, cy + half_h),
            (cx - half_w, cy + half_h)
        ]
            
    '''
    
    Take the bbox cooridnates from detection message for the person in form x , y = size of bbox which surround the centre and also have the centre point position
    
    Then, take the robot path's small line sgements.
    
    Then, apply the ray-AABB collision check method and if there will be collsion return true and the intersection point.
    
    This is for single line segment an person bbox
    
    run it for all line sgements inside the callback'''
    
    def raycast(self, line_segment: list, bbox_center: list, bbox_size: list):
        intersects = False
        intersection_points = []

        # Calculate the coordinates of the corners of the bounding box
        bbox_corners = self.calculate_bbox_corners(bbox_center, bbox_size)

        # Extract start and end points of the line segment
        x0, y0 = line_segment[0]
        x1, y1 = line_segment[1]

        # Get min and max coordinates of the bounding box
        bbox_min_x = min(point[0] for point in bbox_corners)
        bbox_max_x = max(point[0] for point in bbox_corners)
        bbox_min_y = min(point[1] for point in bbox_corners)
        bbox_max_y = max(point[1] for point in bbox_corners)

        # Calculate ray direction
        dx = x1 - x0
        dy = y1 - y0

        # Initialize variables for t_min and t_max
        t_min = 0
        t_max = float('inf')

        # Check for intersections with vertical planes (x-dimension)
        if dx != 0:
            t1 = (bbox_min_x - x0) / dx
            t2 = (bbox_max_x - x0) / dx
            t_min = max(t_min, min(t1, t2))
            t_max = min(t_max, max(t1, t2))
        else:
            if x0 < bbox_min_x or x0 > bbox_max_x:
                return False, []

        # Check for intersections with horizontal planes (y-dimension)
        if dy != 0:
            t1 = (bbox_min_y - y0) / dy
            t2 = (bbox_max_y - y0) / dy
            t_min = max(t_min, min(t1, t2))
            t_max = min(t_max, max(t1, t2))
        else:
            if y0 < bbox_min_y or y0 > bbox_max_y:
                return False, []

        # Check if there is a valid intersection
        if t_min > t_max or t_max < 0:
            return False, []

        # Calculate the intersection point
        intersection_point = [x0 + t_min * dx, y0 + t_min * dy]
        return True, intersection_point
    

    def play_chicken(self, S, X, Y):  

        '''
        1.) Here, two players ae robot and pedestrian.

        2.) The row player is robot, and the colum player is pedestrian.

        3.) S is the strategy matrix consisting the most optimal actions (FAST/SLOW) to be taken by the robot based on the pedetrian strategy.

        4.) The functions takes the solved strategy matrix, x point =  distance from collsion point and Ped pose, y point = dist. from collsion point and robot pose
        '''                     
       
        Fast = True
        Slow = False
        
        self.prob_robot_yield = S[Y, X, 0]  
        # self.get_logger().info(f'Robot yied prob : {self.prob_robot_yield}')                                          # Action the robot should take either yeild (SLOW) or not yield, carry on (FAST)                        
        prob_ped_yield = S[Y, X, 1]   
        r1 = random.random()                                                                                            # Create a random probabilty range (prob. is max 1)
        
        if r1 < self.prob_robot_yield:  
            print('slowing robot')                                                                                     # check the robot should yeild (SLOW) if yeild probility is higher  
            return  Slow                                                                                                # Slow down the robot by halving the speed in linear.x (fwd/ bkd velocity)  
        else:
            return Fast

    '''
    1.) Take the pair of waypoint to represent small line segment for the whole path of NAV2 instead of just using each waypoint seperately.

    2.) Input the slope and intercept form representing pedestrian linear/straight line motion.

    3.) Now, for every line segment along the path, do ray catsing and find intersection (ray-aabb.)

    4.) After finding the collsion points look for the earliest collsion point happening by storing the time and min (time) will show the earliest collision.

    5.) Then put value to t in equation of pedestrian to find x,y
    
    '''
    def cmd_vel_cb(self, msg):

        curr_time = time()
        delta_time = curr_time - self.old_time
        is_intersect, intersect = self.raycast(self.waypoints, self.bbox_center, self.bbox_size)

        if not is_intersect:
            self.game_played = False

        
        else:
            
            self.game_played = True
            robot_dist_to_collision = np.sqrt((self.robot_pose_x - intersect[0])**2 + (self.robot_pose_y - intersect[1])**2)

            # x_intersect = (self.intercept - self.ped_pose_y)/self.slope
            # y_intersect = self.slope*x_intersect + self.intercept

            ped_dist_to_collision = np.sqrt((self.ped_pose_x - intersect[0])**2 + (self.ped_pose_y - intersect[1])**2)

            self.ped_dist = ped_dist_to_collision
            self.robot_dist = robot_dist_to_collision
            self.X = int(round(robot_dist_to_collision))                                                             # Discretise the points to nearest ints
                                                                                                                # NOTE Quantise points to 1 meter boxes
            self.Y = int(round(ped_dist_to_collision))

            # self.get_logger().info(f'Robot position: {X}, Ped positon: {Y}')


            # if we played chicken once, then do the original but if the time played chicken exceeds some thresh again play

            if delta_time > 0.5:                                                                                      # NOTE check time is in seconds not millis
                self.b_fast =  self.play_chicken(self.S, self.X, self.Y)

                self.old_time = curr_time
            if self.b_fast:
                msg.linear.x/=2

        
        np.set_printoptions(threshold=np.inf, precision=3, linewidth=200, suppress=True)
        # self.get_logger().info(f'strategy matrix: {self.S}')
        self.get_logger().info(f'Robot_dist: {round(self.robot_dist,3)}, R_time {round(self.robot_time_to_collision,3)}, R_curr_x: {round(self.robot_pose_x,3)}, R_curr_y{round(self.robot_pose_y,3)} P_dist: {round(self.ped_dist,3)}, P_time {round(self.ped_time_to_collision,3)}, X_close: {round(self.x_closest,3)}, Y_close: {round(self.y_closest,3)}, Game_Played : {self.game_played}, PRY: {round(self.prob_robot_yield,3)}, Game_twist: {msg.linear.x}, R_player: {self.X}, P_player: {self.Y}')
        print('\n')

        # msg.linear.x =0.0
        self.modulated_twist_pub.publish(msg)
           
         
def main():
    rclpy.init()
    node = ChickenSpeedModulatorNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()




    





